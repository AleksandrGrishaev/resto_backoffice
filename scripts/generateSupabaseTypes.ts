#!/usr/bin/env tsx
/**
 * Generate TypeScript types from Supabase database schema
 * Usage: npx tsx scripts/generateSupabaseTypes.ts
 */

import { createClient } from '@supabase/supabase-js'
import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Load environment variables
import dotenv from 'dotenv'
dotenv.config({ path: path.join(__dirname, '../.env') })
dotenv.config({ path: path.join(__dirname, '../.env.development') })

const supabaseUrl = process.env.VITE_SUPABASE_URL
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseKey) {
  console.error(
    'Error: VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY environment variables are required'
  )
  process.exit(1)
}

console.log('Connecting to Supabase...')
console.log(`URL: ${supabaseUrl}`)

const supabase = createClient(supabaseUrl, supabaseKey)

/**
 * Fetch database schema from information_schema
 */
async function fetchSchema() {
  console.log('Fetching database schema...')

  const { data, error } = await supabase
    .from('information_schema.tables')
    .select('table_name, table_schema')
    .eq('table_schema', 'public')

  if (error) {
    console.error('Error fetching tables:', error)
    return null
  }

  return data
}

/**
 * Fetch column information for a table
 */
async function fetchColumns(tableName: string) {
  const { data, error } = await supabase
    .from('information_schema.columns')
    .select('column_name, data_type, is_nullable, column_default')
    .eq('table_schema', 'public')
    .eq('table_name', tableName)

  if (error) {
    console.error(`Error fetching columns for ${tableName}:`, error)
    return []
  }

  return data || []
}

/**
 * Fetch foreign key relationships
 */
async function fetchRelationships() {
  const { data, error } = await supabase
    .rpc('get_table_relationships')
    .then(r => ({ data: r.data, error: r.error }))
    .catch(() => ({ data: [], error: null }))

  return data || []
}

/**
 * Generate TypeScript type definitions
 */
async function generateTypes() {
  try {
    const tables = await fetchSchema()

    if (!tables || tables.length === 0) {
      console.warn('No tables found in public schema')
      return
    }

    console.log(`Found ${tables.length} tables`)

    let typeDefinitions = `// src/supabase/types.gen.ts - Supabase database types
// Auto-generated from Supabase schema
// Last updated: ${new Date().toISOString()}
// Generated by: scripts/generateSupabaseTypes.ts

export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: '13.0.5'
  }
  public: {
    Tables: {
`

    // Process each table
    for (const table of tables) {
      console.log(`Processing table: ${table.table_name}`)
      const columns = await fetchColumns(table.table_name)

      if (columns.length === 0) {
        console.warn(`  No columns found for ${table.table_name}`)
        continue
      }

      // Start table definition
      typeDefinitions += `      ${table.table_name}: {
        Row: {
`

      // Add row columns
      for (const col of columns) {
        const tsType = mapPostgresToTypeScript(col.data_type, col.is_nullable)
        typeDefinitions += `          ${col.column_name}: ${tsType}
`
      }

      typeDefinitions += `        }
        Insert: {
`

      // Add insert columns
      for (const col of columns) {
        const tsType = mapPostgresToTypeScript(col.data_type, col.is_nullable)
        const isOptional = col.column_default !== null || col.is_nullable === 'YES'
        const typeStr = isOptional ? `${tsType} | undefined` : tsType
        typeDefinitions += `          ${col.column_name}?: ${typeStr}
`
      }

      typeDefinitions += `        }
        Update: {
`

      // Add update columns
      for (const col of columns) {
        const tsType = mapPostgresToTypeScript(col.data_type, col.is_nullable)
        typeDefinitions += `          ${col.column_name}?: ${tsType}
`
      }

      typeDefinitions += `        }
        Relationships: []
      }
`
    }

    typeDefinitions += `    }
    Views: {}
    Functions: {}
    Enums: {}
    CompositeTypes: {}
  }
}
`

    // Write to file
    const outputPath = path.join(__dirname, '../src/supabase/types.gen.ts')
    fs.writeFileSync(outputPath, typeDefinitions)

    console.log(`\n‚úÖ Successfully generated TypeScript types`)
    console.log(`üìÅ Output: ${outputPath}`)
    console.log(`üìä Generated types for ${tables.length} tables`)
  } catch (error) {
    console.error('Error generating types:', error)
    process.exit(1)
  }
}

/**
 * Map PostgreSQL data types to TypeScript
 */
function mapPostgresToTypeScript(pgType: string, isNullable: string): string {
  let tsType = 'unknown'

  // Handle base types
  if (pgType.includes('varchar') || pgType.includes('text') || pgType.includes('char')) {
    tsType = 'string'
  } else if (
    pgType.includes('integer') ||
    pgType.includes('bigint') ||
    pgType.includes('smallint')
  ) {
    tsType = 'number'
  } else if (pgType.includes('decimal') || pgType.includes('numeric') || pgType.includes('real')) {
    tsType = 'number'
  } else if (pgType.includes('boolean') || pgType.includes('bool')) {
    tsType = 'boolean'
  } else if (pgType.includes('timestamp') || pgType.includes('date') || pgType.includes('time')) {
    tsType = 'string'
  } else if (pgType.includes('json') || pgType.includes('jsonb')) {
    tsType = 'Json'
  } else if (pgType.includes('uuid')) {
    tsType = 'string'
  } else if (pgType.includes('bytea')) {
    tsType = 'string'
  }

  // Add null if nullable
  if (isNullable === 'YES') {
    return `${tsType} | null`
  }

  return tsType
}

// Run the generator
generateTypes()
