<!-- src/views/pos/order/OrderSection.vue -->
<template>
  <div class="order-section">
    <!-- Loading Overlay -->
    <div v-if="loading.global" class="loading-overlay">
      <v-progress-circular indeterminate size="48" />
      <div class="text-body-1 mt-2">{{ loadingMessage }}</div>
    </div>

    <!-- Order Content -->
    <template v-if="currentOrder">
      <!-- Order Info Header -->
      <OrderInfo
        :order="currentOrder"
        :table-number="tableNumber"
        :can-edit="canEditOrder"
        @change-type="handleOrderTypeChange"
        @change-table="handleTableChange"
        @update-customer="handleCustomerUpdate"
      />

      <!-- Bills Management -->
      <BillsManager
        :order="currentOrder"
        :bills="bills"
        :active-bill-id="activeBillId"
        :can-add-bill="canAddBill"
        :can-edit-items="canEditItems"
        :has-unsaved-changes="hasUnsavedChanges"
        @select-bill="handleSelectBill"
        @add-bill="handleAddBill"
        @rename-bill="handleRenameBill"
        @remove-bill="handleRemoveBill"
        @update-item-quantity="handleUpdateItemQuantity"
        @modify-item="handleModifyItem"
        @cancel-item="handleCancelItem"
        @add-note="handleAddNote"
        @send-to-kitchen="handleSendToKitchen"
        @move-items="handleMoveItems"
        @checkout="handleCheckout"
      />

      <!-- Order Totals -->
      <OrderTotals
        :totals="orderTotals"
        :bills-breakdown="billsBreakdown"
        :order-stats="orderStats"
        :active-bill-id="activeBillId"
        :show-taxes="showTaxes"
        :service-tax-rate="serviceTaxRate"
        :government-tax-rate="governmentTaxRate"
        :loading="loading.calculations"
        :show-debug-info="debugMode"
      />

      <!-- Order Actions -->
      <OrderActions
        :order="currentOrder"
        :bills="bills"
        :active-bill="activeBill"
        :has-unsaved-changes="hasUnsavedChanges"
        @save="handleSave"
        @send-to-kitchen="handleSendToKitchenFromActions"
        @print="handlePrint"
        @move="handleMoveFromActions"
        @checkout="handleCheckoutFromActions"
      />
    </template>

    <!-- Empty State -->
    <div v-else class="empty-state pa-8">
      <div class="text-center">
        <v-icon size="64" color="grey-darken-2" class="mb-4">mdi-receipt-text-outline</v-icon>
        <div class="text-h6 text-grey-darken-1 mb-2">No Order Selected</div>
        <div class="text-body-2 text-grey-darken-1 mb-4">
          Select a table or create a new order to get started
        </div>
        <v-btn color="primary" variant="flat" @click="handleCreateOrder">
          <v-icon start>mdi-plus</v-icon>
          Create New Order
        </v-btn>
      </div>
    </div>

    <!-- Error Notification -->
    <AppNotification
      :show="error.show"
      :message="error.message"
      :type="error.type === 'error' ? 'error' : 'warning'"
      location="top"
      :timeout="error.timeout"
      @close="clearError"
    />

    <!-- Success Notification -->
    <AppNotification
      :show="success.show"
      :message="success.message"
      type="success"
      location="top"
      :timeout="success.timeout"
      @close="success.show = false"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted } from 'vue'
import { usePosOrdersStore } from '@/stores/pos/orders/ordersStore'
import { usePosTablesStore } from '@/stores/pos/tables/tablesStore'
import { useMenuStore } from '@/stores/menu'
import { useOrderCalculations } from '@/stores/pos/orders/composables/useOrderCalculations'
import type { PosOrder, PosBill, PosBillItem, OrderType } from '@/stores/pos/types'
import type { MenuItem, MenuItemVariant } from '@/stores/menu/types'
import AppNotification from '@/components/atoms/feedback/AppNotification.vue'

// Import components
import OrderInfo from './components/OrderInfo.vue'
import BillsManager from './components/BillsManager.vue'
import OrderTotals from './components/OrderTotals.vue'
import OrderActions from './components/OrderActions.vue'

const MODULE_NAME = 'OrderSection'

// Stores
const ordersStore = usePosOrdersStore()
const tablesStore = usePosTablesStore()
const menuStore = useMenuStore()

// Props
interface Props {
  showTaxes?: boolean
  serviceTaxRate?: number
  governmentTaxRate?: number
  debugMode?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showTaxes: true,
  serviceTaxRate: 5,
  governmentTaxRate: 10,
  debugMode: false
})

// State
const loading = ref({
  global: false,
  calculations: false,
  actions: false
})
const loadingMessage = ref('Processing...')
const error = ref({
  show: false,
  message: '',
  type: 'error' as 'error' | 'warning',
  timeout: 5000
})
const success = ref({
  show: false,
  message: '',
  timeout: 3000
})
const hasUnsavedChanges = ref(false)

// Computed - Main Data
const currentOrder = computed((): PosOrder | null => {
  return ordersStore.currentOrder
})

const bills = computed((): PosBill[] => {
  return currentOrder.value?.bills || []
})

const activeBillId = computed((): string | null => {
  return ordersStore.activeBillId
})

const activeBill = computed((): PosBill | null => {
  return ordersStore.activeBill
})

const tableNumber = computed((): string | null => {
  if (!currentOrder.value?.tableId) return null
  const table = tablesStore.tables.find(t => t.id === currentOrder.value?.tableId)
  return table?.number || null
})

// Order Calculations - using composable
const calculations = useOrderCalculations(() => bills.value, {
  serviceTaxRate: props.serviceTaxRate,
  governmentTaxRate: props.governmentTaxRate,
  includeServiceTax: props.showTaxes,
  includeGovernmentTax: props.showTaxes
})

// Computed - Formatted data for OrderTotals
const orderTotals = computed(() => ({
  subtotal: calculations.subtotal.value,
  itemDiscounts: calculations.itemDiscounts.value,
  billDiscounts: calculations.billDiscounts.value,
  totalDiscounts: calculations.totalDiscounts.value,
  discountedSubtotal: calculations.discountedSubtotal.value,
  serviceTax: calculations.serviceTax.value,
  governmentTax: calculations.governmentTax.value,
  finalTotal: calculations.finalTotal.value,
  paidAmount: calculations.paidAmount.value,
  remainingAmount: calculations.remainingAmount.value
}))

const billsBreakdown = computed(() => {
  return (
    calculations.billsBreakdown.value?.map(breakdown => ({
      id: breakdown.id,
      name: breakdown.name,
      itemsCount: breakdown.itemsCount,
      subtotal: breakdown.subtotal || 0,
      totalDiscounts: breakdown.totalDiscounts || 0,
      finalTotal: breakdown.finalTotal || 0,
      paymentStatus: breakdown.paymentStatus || 'unpaid'
    })) || []
  )
})

const orderStats = computed(() => calculations.orderStats?.value)

// Computed - Capabilities
const canEditOrder = computed((): boolean => {
  return !!currentOrder.value && currentOrder.value.status !== 'cancelled'
})

const canAddBill = computed((): boolean => {
  return !!currentOrder.value && currentOrder.value.status === 'draft'
})

const canRemoveBill = computed((): boolean => {
  return !!currentOrder.value && bills.value.length > 1
})

const canEditItems = computed((): boolean => {
  return !!currentOrder.value && currentOrder.value.status !== 'paid'
})

// Methods - Notifications
const showSuccess = (message: string): void => {
  success.value = { show: true, message, timeout: 3000 }
  setTimeout(() => {
    success.value.show = false
  }, 3000)
}

const showError = (message: string, type: 'error' | 'warning' = 'error'): void => {
  error.value = { show: true, message, type, timeout: 5000 }
}

const clearError = (): void => {
  error.value.show = false
}

// Methods - Order Management
const handleCreateOrder = async (): Promise<void> => {
  try {
    loading.value.global = true
    loadingMessage.value = 'Creating new order...'

    // TODO: Implement order creation logic
    showSuccess('New order created successfully')
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to create order'
    showError(message)
  } finally {
    loading.value.global = false
  }
}

const handleOrderTypeChange = async (newType: OrderType): Promise<void> => {
  if (!currentOrder.value) return

  try {
    loading.value.actions = true
    loadingMessage.value = 'Changing order type...'

    // TODO: Implement order type change logic
    showSuccess(`Order type changed to ${newType}`)
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to change order type'
    showError(message)
  } finally {
    loading.value.actions = false
  }
}

const handleTableChange = async (newTableId: string): Promise<void> => {
  if (!currentOrder.value) return

  try {
    loading.value.actions = true
    loadingMessage.value = 'Moving order to new table...'

    // TODO: Implement table change logic
    showSuccess('Order moved to new table')
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to move order'
    showError(message)
  } finally {
    loading.value.actions = false
  }
}

const handleCustomerUpdate = async (customerInfo: any): Promise<void> => {
  if (!currentOrder.value) return

  try {
    // TODO: Implement customer update logic
    showSuccess('Customer information updated')
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to update customer'
    showError(message)
  }
}

// Methods - Bills Management
const handleSelectBill = (billId: string): void => {
  ordersStore.selectBill(billId)
}

const handleAddBill = async (): Promise<void> => {
  if (!currentOrder.value) return

  try {
    loading.value.actions = true
    loadingMessage.value = 'Adding new bill...'

    const result = await ordersStore.addBillToOrder(currentOrder.value.id, 'New Bill')

    if (result.success) {
      showSuccess('New bill added successfully')
      hasUnsavedChanges.value = true
    } else {
      throw new Error(result.error || 'Failed to add bill')
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to add bill'
    showError(message)
  } finally {
    loading.value.actions = false
  }
}

const handleRenameBill = async (billId: string, newName: string): Promise<void> => {
  try {
    // TODO: Implement bill rename logic
    showSuccess('Bill renamed successfully')
    hasUnsavedChanges.value = true
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to rename bill'
    showError(message)
  }
}

const handleRemoveBill = async (billId: string): Promise<void> => {
  if (!canRemoveBill.value) return

  try {
    // TODO: Implement bill removal logic
    showSuccess('Bill removed successfully')
    hasUnsavedChanges.value = true
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to remove bill'
    showError(message)
  }
}

// Methods - Items Management
const handleUpdateItemQuantity = async (itemId: string, quantity: number): Promise<void> => {
  if (!currentOrder.value || !activeBillId.value) return

  try {
    const result = await ordersStore.updateItemQuantity(
      currentOrder.value.id,
      activeBillId.value,
      itemId,
      quantity
    )

    if (result.success) {
      showSuccess('Item quantity updated')
      hasUnsavedChanges.value = true

      // Пересчитываем итоги заказа
      await ordersStore.recalculateOrderTotals(currentOrder.value.id)
    } else {
      throw new Error(result.error || 'Failed to update quantity')
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to update item quantity'
    showError(message)
  }
}

const handleModifyItem = async (itemId: string): Promise<void> => {
  try {
    // TODO: Implement item modification dialog
    console.log('🔧 Modify item:', itemId)
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to modify item'
    showError(message)
  }
}

const handleCancelItem = async (itemId: string): Promise<void> => {
  if (!currentOrder.value || !activeBillId.value) return

  try {
    const result = await ordersStore.removeItemFromBill(
      currentOrder.value.id,
      activeBillId.value,
      itemId
    )

    if (result.success) {
      showSuccess('Item cancelled successfully')
      hasUnsavedChanges.value = true

      // Пересчитываем итоги заказа
      await ordersStore.recalculateOrderTotals(currentOrder.value.id)
    } else {
      throw new Error(result.error || 'Failed to cancel item')
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to cancel item'
    showError(message)
  }
}

const handleAddNote = async (itemId: string): Promise<void> => {
  try {
    // TODO: Implement add note dialog
    console.log('📝 Add note to item:', itemId)
    showSuccess('Note dialog opened')
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to add note'
    showError(message)
  }
}

// Methods - Actions
const handleSave = async (): Promise<void> => {
  if (!currentOrder.value) return

  try {
    loading.value.actions = true
    loadingMessage.value = 'Saving order...'

    // TODO: Implement save logic
    showSuccess('Order saved successfully')
    hasUnsavedChanges.value = false
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to save order'
    showError(message)
  } finally {
    loading.value.actions = false
  }
}

const handleSendToKitchen = async (itemIds: string[]): Promise<void> => {
  if (!currentOrder.value) return

  try {
    loading.value.actions = true
    loadingMessage.value = 'Sending to kitchen...'

    const result = await ordersStore.sendOrderToKitchen(currentOrder.value.id, itemIds)

    if (result.success) {
      showSuccess(`${itemIds.length} items sent to kitchen`)
      hasUnsavedChanges.value = true
    } else {
      throw new Error(result.error || 'Failed to send to kitchen')
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to send to kitchen'
    showError(message)
  } finally {
    loading.value.actions = false
  }
}

const handleSendToKitchenFromActions = async (): Promise<void> => {
  // Send all new items from active bill or selected items
  const itemIds = ordersStore.selectedItemIds

  if (itemIds.length > 0) {
    await handleSendToKitchen(itemIds)
  } else if (activeBill.value) {
    // Send all new items from active bill
    const newItems = activeBill.value.items.filter(item => item.status === 'pending')
    if (newItems.length > 0) {
      await handleSendToKitchen(newItems.map(item => item.id))
    }
  }
}

const handleMoveItems = (itemIds: string[], sourceBillId: string): void => {
  console.log('📦 Move items action:', {
    itemIds,
    sourceBillId,
    count: itemIds.length
  })

  // TODO: Implement move dialog
  showSuccess(`Moving ${itemIds.length} items`)
}

const handleMoveFromActions = (): void => {
  const selectedCount = ordersStore.selectedItemsCount

  if (selectedCount === 0) {
    showError('Please select items to move', 'warning')
    return
  }

  if (activeBillId.value) {
    handleMoveItems(ordersStore.selectedItemIds, activeBillId.value)
  }
}

const handlePrint = (): void => {
  if (!currentOrder.value) return

  console.log('🖨️ Print bill action')

  // TODO: Implement print functionality
  showSuccess('Bill sent to printer')
}

const handleCheckout = (itemIds: string[], billId: string): void => {
  console.log('💳 Checkout action:', {
    itemIds,
    billId,
    amount: orderTotals.value.finalTotal,
    itemCount: itemIds.length
  })

  // TODO: Implement checkout flow
  showSuccess(
    `Checkout initiated for ${itemIds.length > 0 ? itemIds.length + ' items' : 'all items'}`
  )
}

const handleCheckoutFromActions = (itemIds: string[], amount: number): void => {
  if (activeBillId.value) {
    handleCheckout(itemIds, activeBillId.value)
  }
}

// Watchers
watch(
  () => currentOrder.value?.id,
  (newOrderId, oldOrderId) => {
    if (newOrderId !== oldOrderId) {
      // При смене заказа сбрасываем состояние
      hasUnsavedChanges.value = false
      ordersStore.clearSelection()
    }
  }
)

watch(
  () => activeBill.value?.items.length,
  (newLength, oldLength) => {
    if (newLength !== undefined && oldLength !== undefined && newLength !== oldLength) {
      // При изменении количества элементов проверяем наличие несохраненных изменений
      hasUnsavedChanges.value =
        activeBill.value?.items.some(item => item.status === 'pending') || false
    }
  }
)

// Lifecycle
onMounted(() => {
  if (props.debugMode) {
    console.log('🔍 OrderSection mounted in debug mode')
  }
})
</script>

<style scoped>
/* =============================================
   ORDER SECTION LAYOUT
   ============================================= */

.order-section {
  position: relative;
  height: 100%;
  background: rgb(var(--v-theme-background));
  display: flex;
  flex-direction: column;
}

/* =============================================
   LOADING OVERLAY
   ============================================= */

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(var(--v-theme-surface), 0.8);
  backdrop-filter: blur(4px);
  z-index: 100;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* =============================================
   EMPTY STATE
   ============================================= */

.empty-state {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
}

/* =============================================
   RESPONSIVE DESIGN
   ============================================= */

@media (max-width: 768px) {
  .order-section {
    padding: 0;
  }

  .empty-state {
    padding: var(--spacing-lg);
    min-height: 300px;
  }
}

/* =============================================
   ANIMATIONS
   ============================================= */

.order-section {
  animation: fadeIn 0.3s ease;
}

.loading-overlay {
  animation: fadeIn 0.2s ease;
}

.empty-state {
  animation: slideUp 0.4s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* =============================================
   FOCUS MANAGEMENT
   ============================================= */

.order-section:focus-within {
  outline: none;
}

/* =============================================
   PRINT STYLES
   ============================================= */

@media print {
  .order-section {
    background: white;
  }

  .loading-overlay,
  .empty-state {
    display: none;
  }
}
</style>
