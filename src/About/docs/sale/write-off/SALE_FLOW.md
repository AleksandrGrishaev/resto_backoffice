# Sale Flow Documentation - –ü–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–æ–¥–∞–∂–∏ –∏ —Å–ø–∏—Å–∞–Ω–∏—è

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ

1. [–û–±–∑–æ—Ä –ø—Ä–æ—Ü–µ—Å—Å–∞](#–æ–±–∑–æ—Ä-–ø—Ä–æ—Ü–µ—Å—Å–∞)
2. [–≠—Ç–∞–ø 1: –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ (POS)](#—ç—Ç–∞–ø-1-–æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ-–∑–∞–∫–∞–∑–∞-pos)
3. [–≠—Ç–∞–ø 2: –û–ø–ª–∞—Ç–∞ –∑–∞–∫–∞–∑–∞](#—ç—Ç–∞–ø-2-–æ–ø–ª–∞—Ç–∞-–∑–∞–∫–∞–∑–∞)
4. [–≠—Ç–∞–ø 3: –ó–∞–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø—Ä–æ–¥–∞–∂–∏](#—ç—Ç–∞–ø-3-–∑–∞–ø–∏—Å—å-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏-–ø—Ä–æ–¥–∞–∂–∏)
5. [–≠—Ç–∞–ø 4: –°–ø–∏—Å–∞–Ω–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤](#—ç—Ç–∞–ø-4-—Å–ø–∏—Å–∞–Ω–∏–µ-–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤)
6. [–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏](#—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ-–¥–µ—Ç–∞–ª–∏)
7. [–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫](#–æ–±—Ä–∞–±–æ—Ç–∫–∞-–æ—à–∏–±–æ–∫)

---

## –û–±–∑–æ—Ä –ø—Ä–æ—Ü–µ—Å—Å–∞

**–ü–æ–ª–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–¥–∞–∂–∏ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ 4 —ç—Ç–∞–ø–æ–≤:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   POS        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Payment    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ    Sales     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Write-Off   ‚îÇ
‚îÇ   Order      ‚îÇ     ‚îÇ   Processing ‚îÇ     ‚îÇ  Recording   ‚îÇ     ‚îÇ   Inventory  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  –°–æ–∑–¥–∞–Ω–∏–µ           –û–ø–ª–∞—Ç–∞              –£—á–µ—Ç –ø—Ä–æ–¥–∞–∂         –°–ø–∏—Å–∞–Ω–∏–µ —Å–æ —Å–∫–ª–∞–¥–∞
  –∑–∞–∫–∞–∑–∞             —Å—Ä–µ–¥—Å—Ç–≤–∞–º–∏          + —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å      FIFO + negative
```

**–í—Ä–µ–º–µ–Ω–Ω–∞—è –ª–∏–Ω–∏—è:**

- **POS Order**: –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ (—Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞)
- **Payment**: 1-2 —Å–µ–∫ (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞)
- **Sales Recording**: 2-3 —Å–µ–∫ (DecompositionEngine + CostAdapter)
- **Write-Off**: 3-5 —Å–µ–∫ (DecompositionEngine + WriteOffAdapter + FIFO allocation)

**–û–±—â–µ–µ –≤—Ä–µ–º—è:** ~6-11 —Å–µ–∫—É–Ω–¥

---

## –≠—Ç–∞–ø 1: –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ (POS)

### –§–∞–π–ª—ã:

- `src/stores/pos/orders/ordersStore.ts`
- `src/stores/pos/tables/tablesStore.ts`
- `src/views/pos/order/OrderSection.vue`

### –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

1. **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±–∏—Ä–∞–µ—Ç —Å—Ç–æ–ª/—Ç–∏–ø –∑–∞–∫–∞–∑–∞**

   - –¢–∏–ø: `dine-in`, `takeaway`, `delivery`
   - –î–ª—è `dine-in` –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è —Å—Ç–æ–ª –∏–∑ `tablesStore`

2. **–î–æ–±–∞–≤–ª—è–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –º–µ–Ω—é**

   ```typescript
   order.items.push({
     menuItemId: '1880d1c2-...',
     variantId: 'f2c05dbe-...',
     name: 'Test',
     variantName: 'Dragon',
     quantity: 1,
     price: 100000,
     selectedModifiers: [] // Replacement modifiers
   })
   ```

3. **–°–æ–∑–¥–∞–µ—Ç—Å—è –∑–∞–∫–∞–∑ –≤ ordersStore**
   ```typescript
   ordersStore.createOrder({
     tableId?: string,
     orderType: 'dine-in' | 'takeaway' | 'delivery',
     items: OrderItem[],
     status: 'pending'
   })
   ```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**

- Order —Å–æ–∑–¥–∞–Ω —Å `status: 'pending'`
- Order —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ localStorage (offline-first)
- UI –æ–±–Ω–æ–≤–ª–µ–Ω

---

## –≠—Ç–∞–ø 2: –û–ø–ª–∞—Ç–∞ –∑–∞–∫–∞–∑–∞

### –§–∞–π–ª—ã:

- `src/stores/pos/payments/paymentsStore.ts`
- `src/views/pos/order/dialogs/PaymentDialog.vue`

### –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

1. **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∏–º–∞–µ—Ç "Pay"**

   - –û—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è `PaymentDialog`
   - –í—ã–±–∏—Ä–∞–µ—Ç –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã: `cash`, `card`, `qr`

2. **–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞**

   ```typescript
   // Simple payment (–æ–¥–∏–Ω –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã)
   paymentsStore.processSimplePayment({
     orderId: order.id,
     amount: order.totalAmount,
     paymentMethod: 'cash',
     tendered: 150000
   })

   // Multiple payments (–Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–æ–≤)
   paymentsStore.processMultiplePayments({
     orderId: order.id,
     payments: [
       { method: 'cash', amount: 50000 },
       { method: 'card', amount: 50000 }
     ]
   })
   ```

3. **–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞**
   - Order status: `pending` ‚Üí `paid`
   - Payment record —Å–æ–∑–¥–∞–Ω
   - –ï—Å–ª–∏ `dine-in`: Table status: `occupied` ‚Üí `available`

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**

- Payment —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ –ë–î (`payments` table)
- Order –æ–±–Ω–æ–≤–ª–µ–Ω (`orders` table)
- –°–¥–∞—á–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ (–¥–ª—è cash)

---

## –≠—Ç–∞–ø 3: –ó–∞–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø—Ä–æ–¥–∞–∂–∏

### –§–∞–π–ª—ã:

- `src/stores/sales/salesStore.ts`
- `src/core/decomposition/DecompositionEngine.ts`
- `src/core/decomposition/adapters/CostAdapter.ts`
- `src/core/decomposition/utils/batchAllocationUtils.ts`

### –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

### 3.1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è

```typescript
salesStore.recordSalesTransaction({
  orderId: order.id,
  items: order.items,
  totalRevenue: order.totalAmount,
  paymentMethods: ['cash'],
  shiftId: currentShift.id
})
```

### 3.2. –†–∞—Å—á–µ—Ç –§–ê–ö–¢–ò–ß–ï–°–ö–û–ô —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç–∏ (DecompositionEngine + CostAdapter)

**–§–∞–π–ª—ã:**

- `src/core/decomposition/DecompositionEngine.ts`
- `src/core/decomposition/adapters/CostAdapter.ts`

```typescript
import { createDecompositionEngine, createCostAdapter } from '@/core/decomposition'

// Create engine and adapter
const engine = await createDecompositionEngine()
const costAdapter = createCostAdapter({ department: 'kitchen' })

for (const item of orderItems) {
  // 1. Traverse menu item to get decomposed nodes
  const traversalResult = await engine.traverse(
    {
      menuItemId: item.menuItemId,
      variantId: item.variantId,
      quantity: item.quantity,
      selectedModifiers: item.selectedModifiers
    },
    costAdapter.getTraversalOptions()
  )

  // traversalResult.nodes = [
  //   { type: 'preparation', preparationId: 'ba109...', quantity: 20, unit: 'gram' },
  //   { type: 'product', productId: '5212...', quantity: 5, unit: 'piece' }
  // ]

  // 2. Transform to cost breakdown using FIFO
  const costBreakdown = await costAdapter.transform(traversalResult, input)

  // costBreakdown = {
  //   totalCost: 2000,
  //   preparationCosts: [...],
  //   productCosts: [...],
  //   method: 'FIFO'
  // }

  totalCost += costBreakdown.totalCost
}
```

**FIFO Allocation (via batchAllocationUtils):**

```typescript
// src/core/decomposition/utils/batchAllocationUtils.ts

export async function allocateFromPreparationBatches(
  preparationId: string,
  requiredQuantity: number,
  department: 'kitchen' | 'bar'
): Promise<PreparationCostItem> {
  // 1. Get batches from preparationStore
  const batches = preparationStore.getPreparationBatches(preparationId, department)

  // 2. Allocate FIFO (positive batches first, then negative)
  const allocations = allocateFromBatches(batches, requiredQuantity, b => b.productionDate)

  // 3. Handle deficit with lastKnownCost fallback
  if (deficit > 0) {
    const fallbackCost = preparation.lastKnownCost || 0
    allocations.push({
      batchId: 'fallback-prep-cost',
      batchNumber: 'LAST_KNOWN',
      allocatedQuantity: deficit,
      costPerUnit: fallbackCost
    })
  }

  return {
    preparationId,
    preparationName,
    quantity: requiredQuantity,
    batchAllocations: allocations,
    averageCostPerUnit: avgCost,
    totalCost
  }
}
```

**–í–ê–ñ–ù–û:** –ù–∞ —ç—Ç–æ–º —ç—Ç–∞–ø–µ **–ù–ï –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç write-off**!

- –≠—Ç–æ —Ç–æ–ª—å–∫–æ **—Ä–∞—Å—á–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏** –¥–ª—è profit calculation
- Batches **—á–∏—Ç–∞—é—Ç—Å—è**, –Ω–æ **–Ω–µ –∏–∑–º–µ–Ω—è—é—Ç—Å—è**
- Negative batches **–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è** –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞

### 3.3. –†–∞—Å—á–µ—Ç –ø—Ä–∏–±—ã–ª–∏

```typescript
const profit = {
  revenue: item.finalPrice, // 100,000 IDR
  cost: costBreakdown.totalCost, // 2,000 IDR (from FIFO)
  profit: revenue - cost, // 98,000 IDR
  profitMargin: ((revenue - cost) / revenue) * 100 // 98%
}
```

### 3.4. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏

```typescript
const transaction = {
  id: generateShortId('st-'),
  orderId: order.id,
  timestamp: now,
  revenue: totalRevenue,
  cost: totalCost,
  profit: totalRevenue - totalCost,
  items: items.map(item => ({
    menuItemId: item.menuItemId,
    name: item.name,
    quantity: item.quantity,
    price: item.price,
    cost: item.actualCost
  })),
  paymentMethods: ['cash'],
  shiftId: currentShift.id
}

// Save to Supabase
await supabase.from('sales_transactions').insert(transaction)
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç –≠—Ç–∞–ø–∞ 3:**

- Transaction —Å–æ–∑–¥–∞–Ω–∞ –≤ `sales_transactions` table
- COGS —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–∞ —á–µ—Ä–µ–∑ DecompositionEngine + CostAdapter
- Profit calculated
- –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≠—Ç–∞–ø—É 4 (Write-Off)

---

## –≠—Ç–∞–ø 4: –°–ø–∏—Å–∞–Ω–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤

### –§–∞–π–ª—ã:

- `src/stores/sales/recipeWriteOff/recipeWriteOffStore.ts`
- `src/core/decomposition/DecompositionEngine.ts`
- `src/core/decomposition/adapters/WriteOffAdapter.ts`
- `src/stores/storage/storageService.ts`
- `src/stores/preparation/negativeBatchService.ts`

### –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

### 4.1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Write-Off

```typescript
recipeWriteOffStore.processItemWriteOff({
  menuItemName: item.name,
  menuItemId: item.menuItemId,
  variantId: item.variantId,
  quantity: item.quantity,
  selectedModifiers: item.selectedModifiers,
  salesTransactionId: transaction.id
})
```

### 4.2. –î–ï–ö–û–ú–ü–û–ó–ò–¶–ò–Ø —á–µ—Ä–µ–∑ DecompositionEngine + WriteOffAdapter

**–§–∞–π–ª—ã:**

- `src/core/decomposition/DecompositionEngine.ts`
- `src/core/decomposition/adapters/WriteOffAdapter.ts`

**–¶–µ–ª—å:** –†–∞—Å–∫—Ä—ã—Ç—å menu item –¥–æ —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤ (products/preparations)

```typescript
import { createDecompositionEngine, createWriteOffAdapter } from '@/core/decomposition'

const engine = await createDecompositionEngine()
const writeOffAdapter = createWriteOffAdapter({ department: 'kitchen' })

// 1. Traverse menu item
const traversalResult = await engine.traverse(
  {
    menuItemId: '1880d1c2-...',
    variantId: 'f2c05dbe-...',
    quantity: 1,
    selectedModifiers: [] // Replacement modifiers
  },
  writeOffAdapter.getTraversalOptions()
)

// traversalResult.nodes = DecomposedNode[]
// Each node has: type, quantity, unit, productId/preparationId, etc.

// 2. Transform to WriteOffResult
const writeOffResult = await writeOffAdapter.transform(traversalResult, input)

// writeOffResult.items = WriteOffItem[]
// [
//   { type: 'preparation', id: 'ba109...', quantity: 20, unit: 'gram', name: 'Dragon test' }
// ]
```

**–ê–ª–≥–æ—Ä–∏—Ç–º –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ (DecompositionEngine):**

```typescript
// DecompositionEngine.traverse()
async traverse(input: MenuItemInput, options: TraversalOptions) {
  // 1. Get menu item and variant
  const menuItem = menuStore.getMenuItem(input.menuItemId)
  const variant = menuItem.variants.find(v => v.id === input.variantId)

  // 2. Build replacement map from modifiers
  const replacements = buildReplacementMap(input.selectedModifiers)

  // 3. Process variant composition
  const nodes: DecomposedNode[] = []

  for (const component of variant.composition) {
    // Check for replacement modifier
    const replacement = getReplacementForVariantComponent(
      variant.id,
      component.id,
      replacements
    )

    if (replacement) {
      // Use replacement composition instead
      await this.processComposition(replacement.composition, nodes, options)
    } else {
      // Process original component
      await this.processComponent(component, nodes, options)
    }
  }

  // 4. Merge duplicates if needed
  if (options.mergeDuplicates) {
    mergeNodes(nodes)
  }

  return { nodes, metadata }
}
```

**WriteOffAdapter transforms nodes:**

```typescript
// WriteOffAdapter.transform()
async transform(result: TraversalResult, input: MenuItemInput): Promise<WriteOffResult> {
  const items: WriteOffItem[] = []

  for (const node of result.nodes) {
    if (node.type === 'preparation') {
      items.push({
        type: 'preparation',
        preparationId: node.preparationId,
        preparationName: node.preparationName,
        quantity: node.quantity,
        unit: node.unit
      })
    } else if (node.type === 'product') {
      items.push({
        type: 'product',
        productId: node.productId,
        productName: node.productName,
        quantity: node.quantity,
        unit: node.unit
      })
    }
  }

  return { items, totalItems: items.length }
}
```

### 4.3. FIFO Allocation –∏ —Å–æ–∑–¥–∞–Ω–∏–µ Write-Off

**–§–∞–π–ª:** `src/stores/storage/storageService.ts`

```typescript
storageService.createWriteOff({
  department: 'kitchen',
  reason: 'sale',
  items: writeOffResult.items,
  notes: `Sale transaction: ${salesTransactionId}`,
  userId: currentUser.id,
  shiftId: currentShift.id
})
```

**–î–ª—è –∫–∞–∂–¥–æ–≥–æ item:**

#### –î–ª—è PRODUCT:

```typescript
allocateProductFIFO(productId, quantity, department) {
  // 1. Get active batches
  const batches = storageStore.batches
    .filter(b =>
      b.productId === productId &&
      b.department === department &&
      b.status === 'active' &&
      b.currentQuantity > 0
    )
    .sort(by receiptDate)  // FIFO

  // 2. Allocate
  const allocations = []
  let remaining = quantity

  for (const batch of batches) {
    const allocated = Math.min(remaining, batch.currentQuantity)

    // Update batch
    batch.currentQuantity -= allocated
    if (batch.currentQuantity === 0) {
      batch.status = 'depleted'
    }

    allocations.push({ batchId: batch.id, quantity: allocated })
    remaining -= allocated
  }

  // 3. IF shortage ‚Üí create negative batch
  if (remaining > 0) {
    const cost = await calculateNegativeBatchCost(productId, remaining)
    const negativeBatch = await negativeBatchService.createNegativeBatch({
      productId,
      department,
      quantity: -remaining,
      cost
    })

    allocations.push({
      batchId: negativeBatch.id,
      quantity: remaining,
      isNegative: true
    })
  }

  return allocations
}
```

#### –î–ª—è PREPARATION:

```typescript
allocatePreparationFIFO(preparationId, quantity, department) {
  // 1. Get active batches (including negative!)
  const batches = preparationStore.batches
    .filter(b =>
      b.preparationId === preparationId &&
      b.department === department &&
      b.isActive &&
      b.currentQuantity !== 0
    )
    .sort(by productionDate)  // FIFO

  // 2. Allocate from positive batches first
  let remaining = quantity

  for (const batch of positiveBatches) {
    const allocated = Math.min(remaining, batch.currentQuantity)
    batch.currentQuantity -= allocated
    remaining -= allocated
  }

  // 3. IF shortage ‚Üí create/update negative batch
  if (remaining > 0) {
    const existingNegative = await negativeBatchService.getActiveNegativeBatch(
      preparationId,
      department
    )

    if (existingNegative) {
      // UPDATE existing
      await negativeBatchService.updateNegativeBatch(existingNegative.id, remaining, cost)
    } else {
      // CREATE new
      await negativeBatchService.createNegativeBatch({
        preparationId,
        department,
        quantity: -remaining,
        cost
      })
    }
  }

  return allocations
}
```

### 4.4. –†–∞—Å—á–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–ª—è Negative Batch

**Fallback Chain (5 —É—Ä–æ–≤–Ω–µ–π –¥–ª—è products, 4 –¥–ª—è preparations):**

```
1. Last active batch cost          ‚Üê getLastActiveBatch() ‚Üí batch.costPerUnit
   ‚Üì FAIL
2. Depleted batches average (5—à—Ç)  ‚Üê SELECT FROM *_batches WHERE status='depleted' LIMIT 5
   ‚Üì FAIL
3. last_known_cost from DB         ‚Üê SELECT last_known_cost FROM products/preparations
   ‚Üì FAIL
4. base_cost_per_unit (products)   ‚Üê SELECT base_cost_per_unit FROM products
   ‚Üì FAIL (–∏–ª–∏ N/A –¥–ª—è preparations)
5. 0 + CRITICAL ERROR              ‚Üê console.error() with context
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç –≠—Ç–∞–ø–∞ 4:**

- Write-off operation —Å–æ–∑–¥–∞–Ω–∞
- Batches –æ–±–Ω–æ–≤–ª–µ–Ω—ã (FIFO)
- Negative batches —Å–æ–∑–¥–∞–Ω—ã/–æ–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∏ shortage
- Expense –∑–∞–ø–∏—Å–∞–Ω –≤ Account Store (–µ—Å–ª–∏ affects_kpi)
- Inventory –∞–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω

---

## –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

### Unified Decomposition Architecture

–° Phase 4 —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ (–¥–µ–∫–∞–±—Ä—å 2025) –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è **–µ–¥–∏–Ω—ã–π DecompositionEngine**:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DecompositionEngine                          ‚îÇ
‚îÇ  - traverse(input, options)                                     ‚îÇ
‚îÇ  - Builds replacement map from modifiers                        ‚îÇ
‚îÇ  - Iterates composition                                         ‚îÇ
‚îÇ  - Applies yield adjustment (optional)                          ‚îÇ
‚îÇ  - Converts portions to grams (optional)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ                                     ‚îÇ
           ‚ñº                                     ‚ñº
    WriteOffAdapter                        CostAdapter
    (recipeWriteOffStore)                  (salesStore)
           ‚îÇ                                     ‚îÇ
           ‚ñº                                     ‚ñº
    WriteOffResult                      ActualCostBreakdown
```

**–ö–ª—é—á–µ–≤—ã–µ —Ñ–∞–π–ª—ã:**

| File                                                   | Purpose                   |
| ------------------------------------------------------ | ------------------------- |
| `src/core/decomposition/DecompositionEngine.ts`        | Unified traversal         |
| `src/core/decomposition/adapters/WriteOffAdapter.ts`   | For inventory write-off   |
| `src/core/decomposition/adapters/CostAdapter.ts`       | For FIFO cost calculation |
| `src/core/decomposition/utils/batchAllocationUtils.ts` | Shared FIFO allocation    |

### Portion-Type Preparations Handling

**CRITICAL:** All portion-type preparations (`portionType='portion'`) follow the principle **"Storage in Grams, Display in Portions"**.

#### Storage Rules

All batch data is stored in **base units (grams/ml)**:

```typescript
// Example: Bacon slices 30g preparation
{
  portionType: 'portion',
  portionSize: 30,        // 1 portion = 30 grams
  outputUnit: 'gram',     // Base unit
  lastKnownCost: 115      // IDR per gram
}

// Production batch (stored in DB)
{
  unit: 'gram',           // Always base unit
  initialQuantity: 120,   // 4 portions (120 / 30)
  currentQuantity: 90,    // 3 portions (90 / 30)
  costPerUnit: 115,       // IDR per gram
  totalValue: 10350       // 90 √ó 115
}
```

#### Decomposition Flow

**Portion Conversion Utilities** (`src/core/decomposition/utils/portionUtils.ts`):

- `convertPortionToGrams()` - Converts portions to base units (grams)
- `getPortionMultiplier()` - Gets variant multiplier (e.g., "no ice" = 1.3x)
- `isPortionUnit()` - Checks if unit is portion-based
- `normalizeUnit()` - Normalizes unit strings (e.g., 'g' ‚Üí 'gram')

```
Menu Item: "1 portion of Bacon"
         ‚Üì
DecompositionEngine (portionUtils.convertPortionToGrams):
  - Input: { quantity: 1, unit: 'portion' }, prep.portionSize: 30
  - Convert: 1 √ó 30g = 30 grams
  - Output: { quantity: 30, unit: 'gram', wasConverted: true }
         ‚Üì
Step 3 (Sales COGS) - CostAdapter:
  - Required: 30 grams
  - FIFO Allocation: allocate from batches (stored in grams)
  - Cost: 30g √ó 115 IDR/gram = 3,450 IDR
  - NO CONVERSION NEEDED (already per-gram)
         ‚Üì
Step 4 (Write-Off) - WriteOffAdapter:
  - Required: 30 grams
  - FIFO Allocation: deduct from batches (stored in grams)
  - Update: currentQuantity -= 30
  - NO CONVERSION NEEDED
         ‚Üì
UI Display:
  - Show: "1 portion (30g)"
  - Cost: "Rp 115/gram (Rp 3,450/portion)"
```

#### Critical Rules

1. **Storage Layer (Database):**

   - ‚úÖ Always store `quantity` in **grams** (base unit)
   - ‚úÖ Always store `cost_per_unit` in **IDR/gram** (per base unit)
   - ‚úÖ Use `unit='gram'` for all batches (production & negative)

2. **Decomposition Layer:**

   - ‚úÖ Convert portions ‚Üí grams **once** in DecompositionEngine (via portionUtils)
   - ‚úÖ Output quantity always in grams
   - ‚úÖ No `portionSize` in DecomposedPreparationNode (not needed)

3. **Cost Calculation Layer:**

   - ‚úÖ All costs are per-gram (base unit)
   - ‚úÖ NO conversion in batchAllocationUtils
   - ‚úÖ NO conversion in CostAdapter
   - ‚úÖ Multiply: `quantity(grams) √ó cost(per-gram) = total`

4. **UI Layer:**
   - ‚úÖ Convert grams ‚Üí portions **for display only**
   - ‚úÖ Show both: "Rp 115/gram (Rp 3,450/portion)"
   - ‚úÖ Use `formatBatchQuantity()` to display portions

#### Example: Sale Transaction with Portion-Type Preparation

**Menu Item:** "Breakfast Plate" (contains 2 portions of Bacon slices 30g)

```
Step 1: POS Order
  - User orders "Breakfast Plate"
  - Order item: { menuItemId, variantId, quantity: 1 }

Step 2: Payment
  - Amount: Rp 50,000
  - Status: paid

Step 3: Sales Recording (CostAdapter)
  - DecompositionEngine traverses menu item
  - Finds component: { type: 'preparation', id: 'bacon', quantity: 2, unit: 'portion' }
  - portionUtils converts: 2 portions √ó 30g = 60 grams
  - Output node: { type: 'preparation', quantity: 60, unit: 'gram' }
  - CostAdapter allocates:
    * Batch PROD-001: 40g √ó 115 IDR/g = 4,600 IDR
    * Batch PROD-002: 20g √ó 115 IDR/g = 2,300 IDR
    * Total cost: 6,900 IDR (for 60g = 2 portions)
  - Sales transaction created with actualCost: 6,900 IDR

Step 4: Write-Off (WriteOffAdapter)
  - Same decomposition: 60 grams of Bacon
  - FIFO allocation deducts from batches:
    * Batch PROD-001: currentQuantity 120 ‚Üí 80 (40g used)
    * Batch PROD-002: currentQuantity 50 ‚Üí 30 (20g used)
  - Write-off record: { itemId: 'bacon', quantity: 60, unit: 'gram' }

UI Display (Write-Off History):
  - Item: "Bacon slices 30g"
  - Quantity: "2/4 portions" (60/120 grams)
  - Cost: "Rp 6,900" (60g √ó 115 IDR/g)
  - Unit cost: "Rp 115/gram (Rp 3,450/portion)"
```

#### Common Mistakes to Avoid

‚ùå **WRONG: Storing quantity in portions**

```typescript
// BAD
{
  unit: 'portion',
  currentQuantity: 3,    // WRONG!
  costPerUnit: 3450      // per-portion - WRONG!
}
```

‚úÖ **CORRECT: Storing quantity in grams**

```typescript
// GOOD
{
  unit: 'gram',
  currentQuantity: 90,   // 3 portions = 90 grams
  costPerUnit: 115       // per-gram
}
```

‚ùå **WRONG: Converting cost in allocation**

```typescript
// BAD - leads to 30x lower cost
if (portionSize) {
  cost = cost / portionSize // WRONG!
}
```

‚úÖ **CORRECT: Use cost as-is**

```typescript
// GOOD - cost is already per-gram
totalCost = quantity * costPerUnit
```

### –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É Step 3 –∏ Step 4

| –ê—Å–ø–µ–∫—Ç               | Step 3 (Sales COGS)                | Step 4 (Write-Off)              |
| -------------------- | ---------------------------------- | ------------------------------- |
| **–¶–µ–ª—å**             | –ü–æ—Å—á–∏—Ç–∞—Ç—å —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–ª—è profit | –°–ø–∏—Å–∞—Ç—å —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã |
| **Adapter**          | CostAdapter                        | WriteOffAdapter                 |
| **–î–µ–π—Å—Ç–≤–∏–µ**         | –ß–∏—Ç–∞–µ—Ç batches (read-only)         | –ò–∑–º–µ–Ω—è–µ—Ç batches (write)        |
| **Negative batches** | –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞             | –°–æ–∑–¥–∞–µ—Ç –ø—Ä–∏ shortage            |
| **–û–±–Ω–æ–≤–ª—è–µ—Ç –ë–î**     | –ù–µ—Ç                                | –î–∞                              |

### Negative Batches

**–ß—Ç–æ —ç—Ç–æ:**

- Batch —Å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º `currentQuantity`
- –ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç "–¥–æ–ª–≥" –ø–µ—Ä–µ–¥ —Å–∫–ª–∞–¥–æ–º
- –°–æ–∑–¥–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞ —Å–ø–∏—Å—ã–≤–∞–µ–º –±–æ–ª—å—à–µ —á–µ–º –µ—Å—Ç—å

**Reconciliation:**

- –ö–æ–≥–¥–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π receipt ‚Üí negative batch reconciled
- Status: `active` ‚Üí `depleted`
- `reconciled_at` –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è

### Replacement Modifiers

–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è **Replacement Modifiers** - –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∑–∞–º–µ–Ω–∏—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Ä–µ—Ü–µ–ø—Ç–∞:

```
Recipe: Cappuccino
‚îú‚îÄ‚îÄ Espresso: 30ml
‚îî‚îÄ‚îÄ Regular Milk: 150ml  ‚Üê –∑–∞–º–µ–Ω—è–µ–º—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç

–ü—Ä–∏ –∑–∞–∫–∞–∑–µ —Å Oat Milk:
‚îú‚îÄ‚îÄ Espresso: 30ml
‚îî‚îÄ‚îÄ Oat Milk: 150ml  ‚Üê –∑–∞–º–µ–Ω–∞ –∏–∑ modifier composition
```

**–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ DecompositionEngine:**

```typescript
const replacements = buildReplacementMap(selectedModifiers)
const replacement = getReplacementForComponent(recipeId, componentId, replacements)
if (replacement) {
  // Use replacement.composition instead of original
}
```

---

## –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### –û—à–∏–±–∫–∞ –≤ Payment (Step 2)

```typescript
try {
  await paymentsStore.processSimplePayment(...)
} catch (error) {
  // Rollback: order status ‚Üí 'pending'
  // Payment –ù–ï —Å–æ–∑–¥–∞–Ω
  // Sales transaction –ù–ï —Å–æ–∑–¥–∞–Ω–∞
  // Write-off –ù–ï –≤—ã–ø–æ–ª–Ω–µ–Ω
}
```

### –û—à–∏–±–∫–∞ –≤ Sales Recording (Step 3)

```typescript
try {
  await salesStore.recordSalesTransaction(...)
} catch (error) {
  // Payment –£–ñ–ï —Å–æ–∑–¥–∞–Ω!
  // –ù–æ sales transaction –ù–ï —Å–æ–∑–¥–∞–Ω–∞
  // –ö–†–ò–¢–ò–ß–ù–û: Manual reconciliation required!
}
```

### –û—à–∏–±–∫–∞ –≤ Write-Off (Step 4)

```typescript
try {
  await recipeWriteOffStore.processItemWriteOff(...)
} catch (error) {
  // Payment —Å–æ–∑–¥–∞–Ω
  // Sales transaction —Å–æ–∑–¥–∞–Ω–∞
  // –ù–æ write-off –ù–ï –≤—ã–ø–æ–ª–Ω–µ–Ω

  // –†–µ—à–µ–Ω–∏–µ:
  // 1. Retry –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (3 –ø–æ–ø—ã—Ç–∫–∏)
  // 2. Queue for manual write-off
  // 3. Admin –≤–∏–¥–∏—Ç pending write-offs
}
```

---

## –õ–æ–≥–∏ –∏ Debugging

### Complete Log Flow Example

Below is a **real log sequence** from a successful sale with portion-type preparation (Bacon slices 30g):

#### Step 3: Sales Recording (CostAdapter)

```typescript
// Engine initialization
[INFO] [DecompositionEngine]: Starting decomposition {
  menuItemId: 'ed14a91d-a30d-4840-8c26-6c4602a964a3',
  variantId: '255acc73-739b-424e-adae-6b6a431d9570',
  quantity: 1,
  modifiersCount: 1
}

// Processing preparation
[DEBUG] [DecompositionEngine]: üì¶ Processing preparation {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  preparationName: 'Bacon slices 30g',
  compQuantity: 1,
  multiplier: 1
}

// Portion conversion (KEY STEP!)
[DEBUG] [DecompositionEngine]: Converted portions to grams {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  preparation: 'Bacon slices 30g',
  originalQuantity: 1,
  convertedQuantity: 30,  // 1 portion √ó 30g
  portionSize: 30
}

// Creating node
[DEBUG] [DecompositionEngine]: ‚úÖ Creating preparation node {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  preparationName: 'Bacon slices 30g',
  finalQuantity: 30,  // In grams!
  unit: 'gram'
}

// Cost calculation
[INFO] [CostAdapter]: Calculating actual cost from FIFO batches {
  nodesCount: 3,
  menuItem: 'Test recipe'
}

[DEBUG] [CostAdapter]: üîµ Allocating preparation from batches {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  preparationName: 'Bacon slices 30g',
  quantity: 30,  // Requesting 30 grams
  unit: 'gram',
  department: 'kitchen'
}

// FIFO allocation
[INFO] [BatchAllocationUtils]: Allocating from preparation batches {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  requiredQuantity: 30,
  department: 'kitchen'
}

[DEBUG] [BatchAllocationUtils]: Available preparation batches {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  batchCount: 1,
  positiveBatches: 1,
  negativeBatches: 0,
  totalAvailable: 120  // 4 portions = 120 grams
}

[INFO] [BatchAllocationUtils]: Preparation stock allocated successfully {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  required: 30,
  allocated: 30,
  batchesUsed: 1
}

// Cost breakdown (NO CONVERSION HERE!)
[INFO] [BatchAllocationUtils]: Preparation cost breakdown {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  preparationName: 'Bacon slices 30g',
  totalCost: 3450,  // 30g √ó 115 IDR/g
  avgCostPerUnit: 115,  // Already per-gram
  allocations: [{
    batchId: 'ad2375c4',
    qty: 30,
    cost: 115,
    total: 3450
  }]
}

[INFO] [CostAdapter]: Actual cost calculated {
  totalCost: 13820.9,
  preparationItems: 2,
  productItems: 1
}
```

#### Step 4: Write-Off (WriteOffAdapter)

```typescript
// Write-off starts
[RecipeWriteOffStore] üîÑ Processing write-off for item: {
  menuItemName: 'Test recipe',
  quantity: 1,
  salesTransactionId: 'st-1766128497893-qspegolx2'
}

// Same decomposition (reuses engine)
[INFO] [DecompositionEngine]: Decomposition complete {
  totalNodes: 3,
  products: 1,
  preparations: 2
}

[INFO] [WriteOffAdapter]: Transforming traversal result for write-off {
  nodesCount: 3,
  menuItem: 'Test recipe'
}

[INFO] [WriteOffAdapter]: Write-off transformation complete {
  totalItems: 3,
  products: 1,
  preparations: 2,
  totalBaseCost: 5840
}

// FIFO deduction
[INFO] [StorageService]: Creating write-off operation {
  documentNumber: 'WO-498301',
  department: 'kitchen',
  reason: 'sales_consumption',
  itemsCount: 3
}

[INFO] [StorageService]: Preparation FIFO allocation complete {
  preparationId: '701d0e2d-38fa-42bc-acdb-99889fc638a9',
  department: 'kitchen',
  needed: 30,  // 30 grams
  batchesUsed: 1,
  hasShortage: false
}

// Batch updated
[INFO] [StorageService]: ‚úÖ Write-off created successfully {
  documentNumber: 'WO-498301',
  reason: 'sales_consumption',
  affectsKPI: false,
  batchesUsed: 3,
  totalValue: 13820.9
}

// Result: Batch currentQuantity: 120 ‚Üí 90 (deducted 30 grams)
```

### Key Log Patterns to Watch

**‚úÖ GOOD - Portion Conversion:**

```
[DEBUG] Converted portions to grams {
  originalQuantity: 1,
  convertedQuantity: 30,
  portionSize: 30
}
```

**‚úÖ GOOD - Cost Calculation (no conversion):**

```
[INFO] Preparation cost breakdown {
  totalCost: 3450,     // 30g √ó 115 IDR/g
  avgCostPerUnit: 115  // Already per-gram
}
```

**‚ùå BAD - Would indicate bug:**

```
[ERROR] CostAdapter: Failed to allocate preparation {
  error: 'portionSize is not defined'  // Bug! Should never happen
}
```

**‚ö†Ô∏è WARNING - Fallback used:**

```
[INFO] Using lastKnownCost fallback for preparation {
  preparationId: '...',
  deficitQuantity: 30,
  fallbackCost: 115  // No batches available
}
```

### Debugging checklist:

1. **–ü—Ä–æ–≤–µ—Ä–∏—Ç—å decomposition:**

   ```typescript
   const engine = await createDecompositionEngine()
   const result = await engine.traverse(input, options)
   console.log('Decomposed nodes:', result.nodes)
   ```

2. **–ü—Ä–æ–≤–µ—Ä–∏—Ç—å batches:**

   ```typescript
   const batches = preparationStore.getPreparationBatches(preparationId, 'kitchen')
   console.log('Available batches:', batches)
   ```

3. **–ü—Ä–æ–≤–µ—Ä–∏—Ç—å cost allocation:**
   ```typescript
   const costItem = await allocateFromPreparationBatches(preparationId, quantity, 'kitchen')
   console.log('Cost breakdown:', costItem)
   ```

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

**–ü–æ–ª–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–¥–∞–∂–∏ - —ç—Ç–æ 4 —ç—Ç–∞–ø–∞:**

1. **POS Order** - —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞
2. **Payment** - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞
3. **Sales Recording** - DecompositionEngine + CostAdapter ‚Üí COGS
4. **Write-Off** - DecompositionEngine + WriteOffAdapter ‚Üí inventory

**–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ (Phase 4):**

- **Unified DecompositionEngine** - –µ–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
- **Adapters pattern** - CostAdapter –∏ WriteOffAdapter
- **Shared FIFO allocation** - batchAllocationUtils
- **Negative batches** –ø—Ä–∏ shortage
- **Replacement modifiers** support
- **~1,728 lines removed** - —É–¥–∞–ª–µ–Ω –¥—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è –∫–æ–¥

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:**

- [DECOMPOSITION_ARCHITECTURE.md](./DECOMPOSITION_ARCHITECTURE.md) - –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- [REFACTORING_PLAN.md](./REFACTORING_PLAN.md) - –ø–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞
