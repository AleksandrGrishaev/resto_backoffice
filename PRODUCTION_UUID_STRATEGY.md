# Production UUID Migration Strategy

**Date:** 2025-12-02
**Target:** Fresh production database with UUID from day 1

## üéØ Strategy Overview

Since production database is **empty**, we can:

1. ‚úÖ Use UUID for accounts from the beginning (no migration needed!)
2. ‚úÖ Avoid complex string ‚Üí UUID migration from Sprint 1 plan
3. ‚úÖ Keep dev database as-is (string IDs) - it already works
4. ‚úÖ Make code support BOTH formats (backwards compatibility)

---

## üìã Step-by-Step Plan

### Step 1: Create Production Accounts with UUID (Manual)

**Run this on PRODUCTION database BEFORE migrations:**

```sql
-- Create main accounts with UUID (generated by Supabase)
INSERT INTO accounts (name, type, initial_balance, current_balance, is_operational, description) VALUES
  ('Main Cash Register', 'cash', 0, 0, true, 'Main cash register for POS operations and daily expenses'),
  ('Bank Account - BCA', 'bank', 0, 0, true, 'Primary bank account for QR payments and transfers'),
  ('Card Terminal', 'card', 0, 0, true, 'Card payment terminal for credit/debit transactions');

-- Display created accounts and their UUIDs
SELECT id, name, type, is_operational FROM accounts ORDER BY created_at;
```

**Save the output!** You'll need these UUIDs for Step 2.

**Example output:**

```
id                                   | name                  | type | is_operational
-------------------------------------|-----------------------|------|---------------
a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d | Main Cash Register    | cash | true
b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6e | Bank Account - BCA    | bank | true
c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f | Card Terminal         | card | true
```

---

### Step 2: Modify Migration 019 for Production

**Option A: Create production-specific migration**

Create: `src/supabase/migrations/019_create_payment_methods_table_prod.sql`

```sql
-- Migration: 019_create_payment_methods_table (PRODUCTION VERSION)
-- Uses UUIDs discovered from Step 1

-- ... (table creation same as original) ...

-- SEED DATA: Use actual UUIDs from production accounts
-- ‚ö†Ô∏è REPLACE THESE UUIDs WITH YOUR ACTUAL VALUES FROM STEP 1!
INSERT INTO payment_methods (name, code, type, account_id, is_active, requires_details, display_order, icon, description) VALUES
  -- Cash ‚Üí Main Cash Register UUID
  ('Cash', 'cash', 'cash', 'a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d'::uuid, true, false, 1, 'mdi-cash', 'Cash payments - Main cash register'),

  -- Card ‚Üí Card Terminal UUID
  ('Credit/Debit Card', 'card', 'card', 'c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f'::uuid, true, true, 2, 'mdi-credit-card', 'Card payments via terminal'),

  -- QR ‚Üí Bank Account BCA UUID
  ('QR Code (QRIS)', 'qr', 'bank', 'b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6e'::uuid, true, false, 3, 'mdi-qrcode', 'QR code payments to bank account')

ON CONFLICT (code) DO NOTHING;
```

**Option B: Modify migration 019 to query accounts dynamically**

```sql
-- Dynamic approach - finds accounts by name
DO $$
DECLARE
  cash_account_id UUID;
  bank_account_id UUID;
  card_account_id UUID;
BEGIN
  -- Find accounts by name
  SELECT id INTO cash_account_id FROM accounts WHERE name = 'Main Cash Register' LIMIT 1;
  SELECT id INTO bank_account_id FROM accounts WHERE name = 'Bank Account - BCA' LIMIT 1;
  SELECT id INTO card_account_id FROM accounts WHERE name = 'Card Terminal' LIMIT 1;

  -- Insert payment methods
  INSERT INTO payment_methods (name, code, type, account_id, is_active, requires_details, display_order, icon, description) VALUES
    ('Cash', 'cash', 'cash', cash_account_id, true, false, 1, 'mdi-cash', 'Cash payments'),
    ('Credit/Debit Card', 'card', 'card', card_account_id, true, true, 2, 'mdi-credit-card', 'Card payments'),
    ('QR Code (QRIS)', 'qr', 'bank', bank_account_id, true, false, 3, 'mdi-qrcode', 'QR payments')
  ON CONFLICT (code) DO NOTHING;
END $$;
```

**Recommendation:** Use Option B (dynamic) - more flexible and doesn't require manual UUID copying.

---

### Step 3: Update Code to Support Both Formats

**Create:** `src/config/accounts.ts`

```typescript
// Runtime account configuration
// Supports both string IDs (dev) and UUID (production)

interface AccountConfig {
  id: string | null
  name: string
  type: 'cash' | 'bank' | 'card'
}

export const ACCOUNT_CONFIG = {
  POS_CASH: {
    id: null as string | null,
    name: 'Main Cash Register',
    type: 'cash'
  },
  BANK_PRIMARY: {
    id: null as string | null,
    name: 'Bank Account - BCA',
    type: 'bank'
  },
  CARD_TERMINAL: {
    id: null as string | null,
    name: 'Card Terminal',
    type: 'card'
  }
} as const

let initialized = false

/**
 * Initialize account IDs from database
 * Call this once on app startup
 */
export async function initializeAccountConfig(supabase: any) {
  if (initialized) return

  try {
    const { data: accounts, error } = await supabase
      .from('accounts')
      .select('id, name, type')
      .in('name', ['Main Cash Register', 'Bank Account - BCA', 'Card Terminal'])

    if (error) throw error

    // Map accounts to config
    accounts?.forEach((acc: any) => {
      if (acc.name === 'Main Cash Register') {
        ACCOUNT_CONFIG.POS_CASH.id = acc.id
      } else if (acc.name === 'Bank Account - BCA') {
        ACCOUNT_CONFIG.BANK_PRIMARY.id = acc.id
      } else if (acc.name === 'Card Terminal') {
        ACCOUNT_CONFIG.CARD_TERMINAL.id = acc.id
      }
    })

    initialized = true
    console.log('‚úÖ Account config initialized:', {
      cash: ACCOUNT_CONFIG.POS_CASH.id,
      bank: ACCOUNT_CONFIG.BANK_PRIMARY.id,
      card: ACCOUNT_CONFIG.CARD_TERMINAL.id
    })
  } catch (error) {
    console.error('‚ùå Failed to initialize account config:', error)
  }
}

/**
 * Get POS cash account ID
 * Throws if not initialized
 */
export function getPOSCashAccountId(): string {
  if (!ACCOUNT_CONFIG.POS_CASH.id) {
    throw new Error('Account config not initialized. Call initializeAccountConfig() first.')
  }
  return ACCOUNT_CONFIG.POS_CASH.id
}

/**
 * Check if an ID is UUID format
 */
export function isUUID(id: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
  return uuidRegex.test(id)
}

/**
 * Backwards compatibility: map old string IDs to new UUIDs
 * Only needed if you want to support old code
 */
export function normalizeAccountId(id: string): string {
  // If already UUID, return as-is
  if (isUUID(id)) return id

  // Map old string IDs (dev environment)
  const legacyMapping: Record<string, string> = {
    acc_1: ACCOUNT_CONFIG.POS_CASH.id || 'acc_1',
    acc_2: ACCOUNT_CONFIG.BANK_PRIMARY.id || 'acc_2',
    acc_3: ACCOUNT_CONFIG.CARD_TERMINAL.id || 'acc_3'
  }

  return legacyMapping[id] || id
}
```

---

### Step 4: Initialize Config on App Startup

**Update:** `src/core/appInitializer.ts`

```typescript
import { initializeAccountConfig } from '@/config/accounts'
import { supabase } from '@/config/supabase'

export async function initializeApp() {
  // ... existing initialization ...

  // Initialize account config
  await initializeAccountConfig(supabase)

  // ... rest of initialization ...
}
```

---

### Step 5: Update Store References

**Update:** `src/stores/account/types.ts`

```typescript
import { getPOSCashAccountId } from '@/config/accounts'

// BEFORE:
// export const POS_CASH_ACCOUNT_ID = 'acc_1'

// AFTER:
// Dynamic getter that works with both UUID and string IDs
export const getPOSCashAccount = () => {
  try {
    return getPOSCashAccountId()
  } catch (error) {
    // Fallback for dev environment
    console.warn('Using fallback POS cash account ID')
    return 'acc_1'
  }
}
```

**Update usage in code:**

```typescript
// BEFORE:
import { POS_CASH_ACCOUNT_ID } from '@/stores/account/types'
if (accountId === POS_CASH_ACCOUNT_ID) { ... }

// AFTER:
import { getPOSCashAccount } from '@/stores/account/types'
if (accountId === getPOSCashAccount()) { ... }
```

---

### Step 6: Update Shift Sync Adapter

**Update:** `src/core/sync/adapters/ShiftSyncAdapter.ts`

Replace all `'acc_1'` references:

```typescript
import { getPOSCashAccount } from '@/stores/account/types'

// BEFORE:
accountId: 'acc_1'

// AFTER:
accountId: getPOSCashAccount()
```

---

### Step 7: Deployment Checklist

**For Production (Clean DB):**

1. ‚úÖ Step 1: Create accounts with UUID (manual SQL)
2. ‚úÖ Save UUIDs for reference
3. ‚úÖ Run migrations 013-018, 020-031 (skip original 019)
4. ‚úÖ Run modified migration 019 (with dynamic account lookup)
5. ‚úÖ Verify payment_methods created correctly
6. ‚úÖ Deploy updated code with account config initialization
7. ‚úÖ Test POS operations
8. ‚úÖ Test account operations
9. ‚úÖ Start adding real data

**For Dev (Existing Data):**

1. ‚úÖ NO CHANGES NEEDED
2. ‚úÖ Code supports both string IDs and UUIDs
3. ‚úÖ `normalizeAccountId()` provides backwards compatibility
4. ‚úÖ Optional: Later migrate to UUID using Sprint 1 plan

---

## üéØ Benefits of This Approach

### Production:

- ‚úÖ UUID from day 1 (industry standard)
- ‚úÖ No complex migration needed (DB is empty)
- ‚úÖ Scalable and future-proof
- ‚úÖ No hardcoded ID dependencies

### Dev:

- ‚úÖ Keeps working as-is (no disruption)
- ‚úÖ No data migration required immediately
- ‚úÖ Can migrate later when convenient
- ‚úÖ Backwards compatibility preserved

### Code:

- ‚úÖ Works with BOTH formats
- ‚úÖ Runtime initialization (flexible)
- ‚úÖ Easy to test and debug
- ‚úÖ Graceful fallbacks

---

## ‚ö†Ô∏è Important Notes

1. **Account Names Must Match**

   - Code uses `'Main Cash Register'`, `'Bank Account - BCA'`, `'Card Terminal'`
   - If you use different names, update `ACCOUNT_CONFIG` in `src/config/accounts.ts`

2. **Initialization Order**

   - Must call `initializeAccountConfig()` BEFORE any POS/account operations
   - Best place: `src/core/appInitializer.ts`

3. **Dev vs Production**

   - Dev: Uses `'acc_1'`, `'acc_2'`, `'acc_3'` (backwards compatible)
   - Production: Uses UUID (new standard)
   - Code supports both transparently

4. **Migration 019**

   - Use dynamic version (Option B) for production
   - Queries accounts by name, not hardcoded IDs
   - Works with any UUID format

5. **Migrations 027, 028, 029**
   - Safe on empty production (no data = no inserts)
   - Will need update if you backfill data later
   - For now: skip or let them run (they'll do nothing)

---

## üöÄ Next Steps After This

Once production is running with UUID:

1. **Generate TypeScript types from DB**

   ```bash
   npx supabase gen types typescript --project-id <prod-id> > src/supabase/types.prod.ts
   ```

2. **Optionally migrate Dev to UUID**

   - Use Sprint 1 plan when ready
   - Not urgent - code already supports both

3. **Update documentation**

   - CLAUDE.md: Document UUID strategy
   - README: Add account initialization instructions

4. **Monitor and validate**
   - Check logs for account ID issues
   - Verify POS operations work
   - Test account transactions

---

## üìù Summary

**TL;DR:**

- Production: UUID from day 1 ‚úÖ
- Dev: Keep string IDs ‚úÖ
- Code: Support both ‚úÖ
- No complex migration needed ‚úÖ

This is the **simplest and cleanest** approach for your situation!
